- Use a secure serializer instead, and **don't allow an attacker to specify an arbitrary type to deserialize**. For more information see the [Preferred alternatives](/dotnet/standard/serialization/binaryformatter-security-guide#preferred-alternatives).
- Make the serialized data tamper-proof. After serialization, cryptographically sign the serialized data. Before deserialization, validate the cryptographic signature. Protect the cryptographic key from being disclosed and design for key rotations.
- This option will still your code vulnerable to denial of service attacks and possible remote code execution attacks in the future. For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide). Restrict deserialized types. Implement a custom System.Runtime.Serialization.SerializationBinder. Before deserializing with NetDataContractSerializer, set the Binder property to an instance of your custom SerializationBinder in all code paths. In the overridden BindToType method, if the type is unexpected, throw an exception to stop deserialization.
