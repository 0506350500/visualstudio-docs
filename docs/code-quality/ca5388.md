---
title: "CA5388: Ensure Sufficient Iteration Count When Using Weak Key Derivation Function"
description: Provides information about code analysis rule CA5388, including causes, how to fix violations, and when to suppress it.
ms.date: 05/08/2020
ms.topic: reference
author: LLLXXXCCC
ms.author: linche
manager: jillfra
ms.workload:
  - "multiple"
f1_keywords:
  - "CA5388"
---
# CA5388: Ensure Sufficient Iteration Count When Using Weak Key Derivation Function

|||
|-|-|
|CheckId|CA5388|
|Category|Microsoft.Security|
|Breaking change|Non-breaking|

## Cause

Iteration count may be smaller than 100k when deriving cryptographic key by <xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=fullName>. Small iteration count makes it vulnerable to dictionary attacks.

## Rule description

This rule checks if the iteraration count is less than 100k possibly when invoking <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A?displayProperty=fullName>.

## How to fix violations

Set the iteration count greater than or equal with 100k before calling <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> explicitly.

## When to suppress warnings

If it is sure that the password is really secure, which has more influence than adding iteration count. Or you can sure that the iteration count can be set correctly.

## Pseudo-code examples

### Violation

```csharp
using System;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var iterations = 100;
        Random r = new Random();

        if (r.Next(6) == 4)
        {
            iterations = 100000;
        }

        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt, iterations);
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### Solution

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.IterationCount = 100000;
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```
