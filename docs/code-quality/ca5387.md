---
title: "CA5387: Do Not Use Weak Key Derivation Function With Insufficient Iteration Count"
description: Provides information about code analysis rule CA5387, including causes, how to fix violations, and when to suppress it.
ms.date: 05/08/2020
ms.topic: reference
author: LLLXXXCCC
ms.author: linche
manager: jillfra
ms.workload:
  - "multiple"
f1_keywords:
  - "CA5387"
---
# CA5387: Do Not Use Weak Key Derivation Function With Insufficient Iteration Count

|||
|-|-|
|CheckId|CA5387|
|Category|Microsoft.Security|
|Breaking change|Non-breaking|

## Cause

Use the default iteration count or set it to less than 100k when deriving cryptographic key by <xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=fullName>. Small iteration count makes it vulnerable to dictionary attacks.

## Rule description

This rule checks if the iteraration count is less than 100k definitely when invoking <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A?displayProperty=fullName>.

## How to fix violations

Set the iteration count greater than or equal with 100k before calling <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>.

## When to suppress warnings

If it is sure that the password is really secure, which has more influence than adding iteration count.

## Pseudo-code examples

### Use the default iteration count

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### Set iteration count by constructor

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt, 100);
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### Set iteration count by property assignment

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.IterationCount = 100;
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### Solution

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.IterationCount = 100000;
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```
