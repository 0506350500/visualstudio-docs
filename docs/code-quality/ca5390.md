---
title: "CA5390: Do not hard-code encryption key"
description: Provides information about code analysis rule CA5390, including causes, how to fix violations, and when to suppress it.
ms.date: 05/08/2020
ms.topic: reference
author: LLLXXXCCC
ms.author: linche
manager: jillfra
ms.workload:
  - "multiple"
f1_keywords:
  - "CA5390"
---
# CA5390: Do not hard-code encryption key

|||
|-|-|
|CheckId|CA5390|
|Category|Microsoft.Security|
|Breaking change|Non-breaking|

## Cause

The `key` parameter of the <xref:System.Security.Cryptography.AesCcm?displayProperty=fullName> or <xref:System.Security.Cryptography.AesGcm?displayProperty=fullName> constructor, <xref:System.Security.Cryptography.SymmetricAlgorithm.Key?displayProperty=fullName> property, or the `rgbKey` of <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A?displayProperty=fullName> or <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor%2A?displayProperty=fullName> method is hard-coded by one of the following:

- Byte array.
- <xref:System.Convert.FromBase64String(System.String)%2A?displayProperty=fullName>.
- All the overloads of <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName>.

## Rule description

For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver. When a key is hard-coded, it is easily discovered. Even with compiled binaries, it is easy to be extracted for malicious users. Once the private key is compromised, the ciphertext can be decrypted directly and is not under protected anymore.

## How to fix violations

- Consider redesigning your application to use a secure key management system, such as Azure Key Vault.
- Keep credentials and keys in a secure location separate from your source code.

## When to suppress warnings

Do not suppress a warning from this rule.

## Pseudo-code examples

### Hard-coded by byte array

```csharp
using System;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(byte[] someOtherBytesForIV)
    {
        byte[] rgbKey = new byte[] {1, 2, 3};
        SymmetricAlgorithm rijn = SymmetricAlgorithm.Create();
        rijn.CreateEncryptor(rgbKey, someOtherBytesForIV);
    }
}
```

### Hard-coded by FromBase64String

```csharp
using System;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(byte[] someOtherBytesForIV)
    {
        byte[] key = Convert.FromBase64String("AAAAAaazaoensuth");
        SymmetricAlgorithm rijn = SymmetricAlgorithm.Create();
        rijn.CreateEncryptor(key, someOtherBytesForIV);
    }
}
```

### Hard-coded by GetBytes

```csharp
using System.Text;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(byte[] someOtherBytesForIV)
    {
        byte[] key = new ASCIIEncoding().GetBytes("AAAAAaazaoensuth");
        SymmetricAlgorithm rijn = SymmetricAlgorithm.Create();
        rijn.CreateEncryptor(key, someOtherBytesForIV);
    }
}
```

### Solution

```csharp
using System.Text;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(char[] chars, byte[] someOtherBytesForIV)
    {
        byte[] key = new ASCIIEncoding().GetBytes(chars);
        SymmetricAlgorithm rijn = SymmetricAlgorithm.Create();
        rijn.CreateEncryptor(key, someOtherBytesForIV);
    }
}
```
