---
title: Visual Studio Container Tools Build Overview
author: ghogen
description: Overview of the Container Tools build process
ms.author: ghogen
ms.date: 06/06/2019
ms.technology: vs-azure
ms.topic: conceptual
---
# Container Tools build process for Visual Studio

This topic explains the Visual Studio build process for containerized apps that use Docker.  For performance reasons, Visual Studio follows a special process for containerized apps. You should understand this process if you plan to customize your build by modifying the Dockerfile.

When Visual Studio builds a project that doesn't use Docker containers, it invokes MSBuild on the local machine and generates the output files in a folder (typically `bin`) under your local solution folder. In the case of a containerized project, however, the build process takes account of the Dockerfile's instructions for building the containerized app. The Dockerfile that Visual Studio uses is divided into multiple stages. This relies on Docker's multistage build feature.

## Multistage build

The multistage build feature helps improve the process of building containers in order to make the build process more efficient and to make containers smaller by allowing them to contain only the bits that are actually needed at runtime, rather than including build artifacts.

The multistage build allows container images to be created in stages that produce intermediate images. As an example, consider a typical Dockerfile generated by Visual Studio - the first stage is `base`:

```
FROM mcr.microsoft.com/dotnet/core/aspnet:2.2-nanoserver-1809 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443
```

The lines in the Dockerfile begin with the Nanoserver image from Microsoft Container Registry (mcr.microsoft.com) and create an intermediate image `base` that exposes ports 80 and 443, and sets the working directory to `/app`.

The next stage is `build`, which appears as follows:

```
FROM mcr.microsoft.com/dotnet/core/sdk:2.2-nanoserver-1809 AS build
WORKDIR /src
COPY ["WebApplication41/WebApplication41.csproj", "WebApplication41/"]
RUN dotnet restore "WebApplication41/WebApplication41.csproj"
COPY . .
WORKDIR "/src/WebApplication41"
RUN dotnet build "WebApplication41.csproj" -c Release -o /app
```

You can see that the `build` stage starts from a different original image from the registry (`sdk` rather than `aspnet`), rather than continuing from base.  The `sdk` image has all the build tools, and for that reason it's a lot bigger than the aspnet image, which only contains runtime components. The reason for doing this becomes clear when you look at the rest of the Dockerfile: 

```
FROM build AS publish
RUN dotnet publish "WebApplication41.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication41.dll"]
```

The final stage starts again from base, and includes the COPY --from=publish to copy the published output to the final image. This makes it possible for the final image to be a lot smaller, since it doesn't need to include all of the build tools that were in the `sdk` image.

## Faster builds for the Debug configuration

For performance reasons, the build process for containerized apps is not as straightforward as simply following the steps outlined in the Dockerfile. Building in a container is much slower than building outside of the container.  This is why when you build in the Debug configuration, Visual Studio actually builds your projects on the local machine, and then shares the output folder to the container using volume mounting. This is called FastMode build.

Visual Studio accomplishes this by invoking `docker build` with an argument that tells Docker to build only the `base` stage.  Visual Studio handles the rest of the process without regard to the contents of the Dockerfile. This is important because when you modify your Dockerfile, such as to customize the container environment or install additional dependencies, any modifications should be placed in the first stage.  Any custom steps placed in the Dockerfile's `build`, `publish`, or `final` stages will not be executed.

This performance optimization only occurs when you build in the Debug configuration. In the Release configuration, the build occurs in the container as specified in the Dockerfile.

If you want to disable the performance optimization and build as the Dockerfile specifies, then set the DockerDevelopmentMode property to [TODO] in the project file as follows:

```xml
<PropertyGroup>
   <DockerDevelopmentMode>[TODO]</DockerDevelopmentMode>
</PropertyGroup>
```

## Docker build context

When using the command line to build containerized solutions, you use the command `docker build <context>` for each project in the solution. You need to provide the *build context* argument. The *build context* for a Dockerfile is the folder on the local machine that's used as the working folder to generate the image. For example, it's the folder that you copy files from when you copy to the container.  In .NET Core projects, this is the folder that contains the solution file (.sln).  Expressed as a relative path, this is typically ".." for the normal case of a Dockerfile in a project folder and the solution file in the parent folder.  For .NET Framework projects, the build context is the project folder, not the solution folder.

> [!NOTE]
> For .NET Framework projects created with versions of Visual Studio prior to Visual Studio 2017 Update 3, the Dockerfile did not use multistage builds. When working with these older Dockerfiles, instead of building the project in the Dockerfile, Visual Studio builds each project and then copies the results to the container. Because the build steps weren't included in the Dockerfile, you can't build those projects using `docker build` from the command line.  To script these builds, run MSBuild separately for each project and then `docker build` to run the Dockerfile in each project and copy the results to the containers.

## Container reuse

During the development cycle, Visual Studio only rebuilds your container images and the container itself when you change the Dockerfile, but if not, it reuses the container from a previous run.

If you have manually modified your container and want to restart from a clean container image, use the **Build** > **Clean** command in Visual Studio, and then build as normal.

## Example: unit testing

A typical case where you might want to modify your Dockerfile is to run unit tests. To add unit tests to a multistage Dockerfile, you typically add a unit-test stage to the Dockerfile between the `build` and `publish` stages.

```
FROM build AS unit-test
RUN dotnet unit-test --logger:trx
```

Visual Studio only runs the first stage in Debug configuration, so the unit-test stages is only run in the Release configuration. But even in Release configuration, the log results won't be included in the final image, because the final image is built from the `base` stage, not from the `unit-test` stage. If you want to run the tests to produce an image that you can access to view the logs, you can do so from the command line as follows:

```cmd
docker build --target:unit-test
```

You can then use the [Container Tools Window](view-and-diagnose-containers.md) (if you have the extension installed) to view the test logs.

For more information, see [dotnet test](/dotnet/core/tools/dotnet-test).

## Next steps

Learn more about [container tools](index.yml) in Visual Studio.

## See also

[MSBuild](../msbuild/msbuild.md)
[Dockerfile on Windows](/virtualization/windowscontainers/manage-docker/manage-windows-dockerfile)
[Linux containers on Windows](/virtualization/windowscontainers/deploy-containers/linux-containers)
